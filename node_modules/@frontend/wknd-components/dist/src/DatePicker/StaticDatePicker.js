"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(require("react"));
var getYear_1 = __importDefault(require("date-fns/getYear"));
var dayzed_1 = require("dayzed");
var IconButton_1 = __importDefault(require("../Button/IconButton"));
var styleguide_1 = require("../styleguide");
var useCalendarOffset_1 = __importDefault(require("./hooks/useCalendarOffset"));
var useDateInView_1 = __importDefault(require("./hooks/useDateInView"));
var DateButton_1 = require("./DateButton");
var DatePicker_consts_1 = require("./DatePicker.consts");
var DatePicker_defaults_1 = require("./DatePicker.defaults");
var MonthSelect_1 = __importDefault(require("./MonthSelect"));
var StaticDatePicker_styles_1 = require("./StaticDatePicker.styles");
var YearSelect_1 = __importDefault(require("./YearSelect"));
var StaticDatePicker = function (_a) {
    var dataQA = _a.dataQA, _b = _a.monthNames, monthNames = _b === void 0 ? DatePicker_consts_1.defaultMonthNamesShort : _b, _c = _a.weekdayNames, weekdayNames = _c === void 0 ? DatePicker_consts_1.defaultWeekdayNames : _c, _d = _a.dayzedProps, _e = _d.minDate, minDate = _e === void 0 ? (0, DatePicker_defaults_1.getDefaultDates)().defaultMinDate : _e, _f = _d.maxDate, maxDate = _f === void 0 ? (0, DatePicker_defaults_1.getDefaultDates)().defaultMaxDate : _f, date = _d.date, restOfDayzedProps = __rest(_d, ["minDate", "maxDate", "date"]), _g = _a.isRange, isRange = _g === void 0 ? false : _g, m = _a.m, mb = _a.mb, ml = _a.ml, mr = _a.mr, mt = _a.mt, className = _a.className;
    var _h = (0, useDateInView_1.default)(date), dateInView = _h.dateInView, setDateInView = _h.setDateInView;
    var _j = (0, useCalendarOffset_1.default)(dateInView), offset = _j.offset, setOffset = _j.setOffset;
    var todaysDate = new Date();
    var useDayzedProps = __assign({ minDate: minDate, maxDate: maxDate, date: dateInView, offset: offset, onOffsetChanged: function (newOffset) { return setOffset(newOffset); } }, restOfDayzedProps);
    var _k = (0, dayzed_1.useDayzed)(useDayzedProps), calendars = _k.calendars, getBackProps = _k.getBackProps, getForwardProps = _k.getForwardProps;
    var _l = (0, react_1.useState)(null), hoveredDate = _l[0], setHoveredDate = _l[1];
    var handleOnMouseEnter = function (enteredDate) {
        setHoveredDate(enteredDate);
    };
    // this takes a number based on arrow keys hit. It will find the active element and move to a date button based on the number in the function
    var getKeyOffset = function (number) {
        var activeElement = document.activeElement;
        var buttons = document.querySelectorAll("[data-calendar-button='calendar-date-button']");
        // we will update the tabindex so that if a user tabs from the focused button, focus will stay within the popover
        buttons.forEach(function (button, i) {
            var newNodeKey = i + number;
            if (button == activeElement) {
                activeElement.setAttribute("tabindex", "-1");
                if (newNodeKey <= buttons.length - 1 && newNodeKey >= 0) {
                    buttons[newNodeKey].focus();
                    buttons[newNodeKey].tabIndex = 0;
                }
            }
        });
    };
    var handleKeyboard = function (event) {
        switch (event.key) {
            case "ArrowLeft":
                getKeyOffset(-1);
                break;
            case "ArrowRight":
                getKeyOffset(1);
                break;
            case "ArrowUp":
                getKeyOffset(-7);
                break;
            case "ArrowDown":
                getKeyOffset(7);
                break;
        }
    };
    var getTabIndex = function (dateObj) {
        var tabIndex = dateObj.today ? 0 : -1;
        // this is required because selected can be either a Date or an array of Dates
        var selectedDateArray = restOfDayzedProps.selected ? restOfDayzedProps.selected.toString().split(",") : [""];
        // if we have a date selected, we want to tab to that date instead of today's date
        if (selectedDateArray.length > 0 && selectedDateArray[0] !== "") {
            tabIndex = dateObj.selected ? 0 : -1;
        }
        // check if selected date or today's date are in the calendar in view
        var selectedShown = false;
        var todayShown = false;
        calendars.forEach(function (cal) {
            var calMonth = cal.month;
            var calYear = cal.year;
            selectedDateArray.filter(function (selectDate) {
                if (!selectedShown) {
                    var selectedDateObj = new Date(selectDate);
                    selectedShown = calMonth === selectedDateObj.getMonth() && calYear == selectedDateObj.getFullYear();
                }
            });
            if (!todayShown) {
                todayShown = calMonth == (todaysDate === null || todaysDate === void 0 ? void 0 : todaysDate.getMonth()) && calYear == (todaysDate === null || todaysDate === void 0 ? void 0 : todaysDate.getFullYear());
            }
        });
        // if selected date and today's date are not in view, tab to the first day of the month
        if (!(selectedShown || todayShown) && dateObj.date.getDate() === calendars[0].firstDayOfMonth.getDate()) {
            tabIndex = 0;
        }
        // if there is a selected date (or range of dates)
        // and the (1st) selected date is not in view,
        // and if today's date is in view, tab to that date
        if (selectedDateArray.length > 0 && selectedDateArray[0] !== ""
            && !selectedShown && todayShown && dateObj.today) {
            tabIndex = 0;
        }
        return tabIndex;
    };
    var getDay = function (dateObj, index) {
        if (!dateObj) {
            return (react_1.default.createElement(StaticDatePicker_styles_1.NoDateContainer, { key: "no-date-".concat(index) }));
        }
        var dateProps = {
            dateObj: dateObj,
        };
        if (isRange) {
            dateProps = __assign(__assign({}, dateProps), { onMouseEnter: function () { return handleOnMouseEnter(dateObj.date); }, onFocus: function () { return handleOnMouseEnter(dateObj.date); } });
        }
        return (react_1.default.createElement(DateButton_1.DateButton, { key: dateObj.date.getTime(), dayzedProps: useDayzedProps, hoveredDate: hoveredDate, dateObj: dateObj, dateProps: dateProps, isRange: isRange, tabIndex: getTabIndex(dateObj) }));
    };
    var datePickerWrapperRangeProps = {
        onMouseLeave: function () { return setHoveredDate(null); },
        onBlur: function () { return setHoveredDate(null); },
    };
    // helps to prevent HTML bloat since the MonthYearWrapper is only needed when there are multiple months displayed
    var MonthYearsContainer = useDayzedProps.monthsToDisplay && useDayzedProps.monthsToDisplay > 1 ? (StaticDatePicker_styles_1.MonthYearWrapper) : (react_1.default.Fragment);
    return (react_1.default.createElement(StaticDatePicker_styles_1.DatePickerWrapper, __assign({ "data-qa": dataQA, m: m, mb: mb, mt: mt, mr: mr, ml: ml, className: className }, (isRange && datePickerWrapperRangeProps)),
        react_1.default.createElement(StaticDatePicker_styles_1.CalendarHeading, null,
            react_1.default.createElement(IconButton_1.default, __assign({ variant: "tertiary", dataQA: "calendar-back", icon: "ChevronLeft", mr: styleguide_1.spacingMap.xxs }, getBackProps({ calendars: calendars }))),
            react_1.default.createElement(MonthYearsContainer, null, calendars.map(function (calendar, calIndex) {
                return react_1.default.createElement(StaticDatePicker_styles_1.MonthYearSelects, { key: "".concat(calendar.month, "-").concat(calendar.year, "-").concat(dataQA), "data-qa": "month-year" },
                    react_1.default.createElement(MonthSelect_1.default, { dataQA: dataQA, month: calendar.month, calendarIndex: calIndex, monthNames: monthNames, setDate: setDateInView, calendarOffset: offset, setCalendarOffset: setOffset, currentSelectedYear: calendar.year, minDate: minDate, maxDate: maxDate }),
                    react_1.default.createElement(YearSelect_1.default, { dataQA: dataQA, currentSelectedYear: calendar.year, month: calendar.month, minYear: (0, getYear_1.default)(minDate), maxYear: (0, getYear_1.default)(maxDate), setDate: setDateInView, calendarOffset: offset, setCalendarOffset: setOffset, calendarIndex: calIndex }));
            })),
            react_1.default.createElement(IconButton_1.default, __assign({ variant: "tertiary", dataQA: "calendar-forward", icon: "ChevronRight", ml: styleguide_1.spacingMap.xxs }, getForwardProps({ calendars: calendars })))),
        react_1.default.createElement(StaticDatePicker_styles_1.Calendars, { onKeyDown: handleKeyboard }, calendars.map(function (calendar) { return (react_1.default.createElement("div", { key: "".concat(calendar.month).concat(calendar.year) },
            react_1.default.createElement(StaticDatePicker_styles_1.WeekdayWrapper, null, weekdayNames.map(function (weekday) { return (react_1.default.createElement(StaticDatePicker_styles_1.Weekday, { dataQA: "".concat(weekday.label, "-weekday"), variant: "caption", color: "".concat(styleguide_1.colors.black, "A8"), key: "".concat(calendar.month).concat(calendar.year).concat(weekday.value), "aria-label": weekday.label }, weekday.value)); })),
            calendar.weeks.map(function (week, weekIndex) {
                return react_1.default.createElement(StaticDatePicker_styles_1.CalendarWeekWrapper, { key: weekIndex }, week.map(function (dateObj, index) { return getDay(dateObj, index); }));
            }))); }))));
};
exports.default = StaticDatePicker;
//# sourceMappingURL=StaticDatePicker.js.map