{"version":3,"file":"DatePicker.utils.js","sourceRoot":"","sources":["../../../src/DatePicker/DatePicker.utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { format, isMatch, isValid, parse } from \"date-fns\";\n\nimport { getDefaultDates } from \"./DatePicker.defaults\";\n\nexport const isCustomMatch = (val: string, formatPattern: string) => {\n\t// this helps to better validate that the string provided is a proper match\n\t// https://github.com/date-fns/date-fns/issues/2785#issuecomment-978066288\n\tif (val.length === formatPattern.length) {\n\t\treturn isMatch(val, formatPattern);\n\t}\n\treturn false;\n};\n\n// helpful to remove the undefined property when setting the selectedDates state\n// this can occur when a startDate is provided but not an endDate\nexport const filterStartAndEndDate = (dates: (Date | undefined)[]) =>\n\tdates.filter((date) => date !== undefined) as Date[];\n\nexport function safeDateFormat(date: number | Date, dateFormat: string) {\n\ttry {\n\t\treturn format(date, dateFormat) || \"\";\n\t} catch (error) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error(error);\n\t\treturn \"\";\n\t}\n}\n\nconst { defaultMinDate, defaultMaxDate } = getDefaultDates();\n\nexport const getMinDate = (minDate?: Date) => minDate || defaultMinDate;\n\nexport const getMaxDate = (maxDate?: Date) => maxDate || defaultMaxDate;\n\nexport const isOutsideMinDate = (newDate: Date, minDate?: Date) => newDate.getTime() <= getMinDate(minDate).getTime();\n\nexport const isOutsideMaxDate = (newDate: Date, maxDate?: Date) =>  newDate.getTime() >= getMaxDate(maxDate).getTime();\n\nexport const getValidDate = (\n\tval: string,\n\tformatPattern: string,\n\tminDate?: Date,\n\tmaxDate?: Date,\n) => {\n\tif (!isCustomMatch(val, formatPattern)) {\n\t\treturn undefined;\n\t}\n\n\t// using parse here to handle dates with a two year string. Without it, dates with \"YY\" will return invalid date\n\tconst newDate = parse(val, formatPattern, new Date());\n\n\tif (isOutsideMinDate(newDate, minDate) || isOutsideMaxDate(newDate, maxDate)) {\n\t\treturn undefined;\n\t}\n\n\tif (!isValid(newDate)) {\n\t\treturn undefined;\n\t}\n\n\treturn newDate;\n};\n\nexport const handleInvalidDate = (\n\tsetDateValue: (value: string) => void,\n\tdateFormat: string,\n\tpreviousDate?: Date,\n) => {\n\tif (previousDate) {\n\t\tsetDateValue(safeDateFormat(previousDate, dateFormat));\n\t} else {\n\t\tsetDateValue(\"\");\n\t}\n};\n\nexport const setNewStartDate = (\n\tnewStartDate: Date,\n\tnewSelectedDates: Date[],\n\tsetSelectedDates: (selectedDates: Date[]) => void,\n\tsetDateInView?: (date: Date) => void,\n) => {\n\t// if there is a start and end date already selected and the new start date is greater than the set end date\n\t// replace them\n\tif (\n\t\tnewSelectedDates.length === 2\n\t\t&& newStartDate.getTime() > newSelectedDates[1].getTime()\n\t) {\n\t\tsetSelectedDates([newSelectedDates[1], newStartDate]);\n\t\tif (setDateInView) {\n\t\t\tsetDateInView(newStartDate);\n\t\t}\n\t\treturn;\n\t}\n\n\tnewSelectedDates.splice(0, 1, newStartDate);\n\tsetSelectedDates(newSelectedDates);\n\n\tif (setDateInView) {\n\t\tsetDateInView(newSelectedDates[0]);\n\t}\n};\n\nconst handleEndDateWithNoStartDate = (\n\tnewEndDate: Date,\n\tsetSelectedDates: (selectedDates: Date[]) => void,\n\tsetDateInView?: (date: Date) => void,\n) => {\n\tsetSelectedDates([newEndDate]);\n\n\tif (setDateInView) {\n\t\tsetDateInView(newEndDate);\n\t}\n};\n\nexport const setNewEndDate = (\n\tnewEndDate: Date,\n\tnewSelectedDates: Date[],\n\tsetSelectedDates: (selectedDates: Date[]) => void,\n\tsetDateInView?: (date: Date) => void,\n) => {\n\tif (!newSelectedDates[0]) {\n\t\treturn handleEndDateWithNoStartDate(newEndDate, setSelectedDates, setDateInView);\n\t}\n\n\t// if the selected length is already equal to two and the new end date time is less than\n\t// the set start date, replace them\n\tif (\n\t\tnewSelectedDates.length === 2\n\t\t&& newEndDate.getTime() < newSelectedDates[0].getTime()\n\t) {\n\t\tsetSelectedDates([newEndDate, newSelectedDates[0]]);\n\n\t\tif (setDateInView) {\n\t\t\tsetDateInView(newSelectedDates[0]);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// if there is no endDate selected and newEndDate is less than the startDate\n\t// set the newEndDate to the startDate and the old startDate to the endDate\n\tif (!newSelectedDates[1]\n\t\t&& newEndDate.getTime() < newSelectedDates[0].getTime()\n\t) {\n\t\tsetSelectedDates([newEndDate, newSelectedDates[0]]);\n\n\t\tif (setDateInView) {\n\t\t\tsetDateInView(newSelectedDates[0]);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// if there is no end date already set, push the new end date;\n\t// otherwise replace the set end date with the new one\n\tif (!newSelectedDates[1]) {\n\t\tnewSelectedDates.push(newEndDate);\n\t\tsetSelectedDates(newSelectedDates);\n\n\t\tif (setDateInView) {\n\t\t\tsetDateInView(newSelectedDates[1]);\n\t\t}\n\t} else {\n\t\tnewSelectedDates.splice(1, 1, newEndDate);\n\t\tsetSelectedDates(newSelectedDates);\n\n\t\tif (setDateInView) {\n\t\t\tsetDateInView(newSelectedDates[1]);\n\t\t}\n\t}\n};\n"]}