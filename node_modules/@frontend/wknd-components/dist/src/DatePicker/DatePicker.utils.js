"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setNewEndDate = exports.setNewStartDate = exports.handleInvalidDate = exports.getValidDate = exports.isOutsideMaxDate = exports.isOutsideMinDate = exports.getMaxDate = exports.getMinDate = exports.safeDateFormat = exports.filterStartAndEndDate = exports.isCustomMatch = void 0;
var date_fns_1 = require("date-fns");
var DatePicker_defaults_1 = require("./DatePicker.defaults");
var isCustomMatch = function (val, formatPattern) {
    // this helps to better validate that the string provided is a proper match
    // https://github.com/date-fns/date-fns/issues/2785#issuecomment-978066288
    if (val.length === formatPattern.length) {
        return (0, date_fns_1.isMatch)(val, formatPattern);
    }
    return false;
};
exports.isCustomMatch = isCustomMatch;
// helpful to remove the undefined property when setting the selectedDates state
// this can occur when a startDate is provided but not an endDate
var filterStartAndEndDate = function (dates) {
    return dates.filter(function (date) { return date !== undefined; });
};
exports.filterStartAndEndDate = filterStartAndEndDate;
function safeDateFormat(date, dateFormat) {
    try {
        return (0, date_fns_1.format)(date, dateFormat) || "";
    }
    catch (error) {
        // eslint-disable-next-line no-console
        console.error(error);
        return "";
    }
}
exports.safeDateFormat = safeDateFormat;
var _a = (0, DatePicker_defaults_1.getDefaultDates)(), defaultMinDate = _a.defaultMinDate, defaultMaxDate = _a.defaultMaxDate;
var getMinDate = function (minDate) { return minDate || defaultMinDate; };
exports.getMinDate = getMinDate;
var getMaxDate = function (maxDate) { return maxDate || defaultMaxDate; };
exports.getMaxDate = getMaxDate;
var isOutsideMinDate = function (newDate, minDate) { return newDate.getTime() <= (0, exports.getMinDate)(minDate).getTime(); };
exports.isOutsideMinDate = isOutsideMinDate;
var isOutsideMaxDate = function (newDate, maxDate) { return newDate.getTime() >= (0, exports.getMaxDate)(maxDate).getTime(); };
exports.isOutsideMaxDate = isOutsideMaxDate;
var getValidDate = function (val, formatPattern, minDate, maxDate) {
    if (!(0, exports.isCustomMatch)(val, formatPattern)) {
        return undefined;
    }
    // using parse here to handle dates with a two year string. Without it, dates with "YY" will return invalid date
    var newDate = (0, date_fns_1.parse)(val, formatPattern, new Date());
    if ((0, exports.isOutsideMinDate)(newDate, minDate) || (0, exports.isOutsideMaxDate)(newDate, maxDate)) {
        return undefined;
    }
    if (!(0, date_fns_1.isValid)(newDate)) {
        return undefined;
    }
    return newDate;
};
exports.getValidDate = getValidDate;
var handleInvalidDate = function (setDateValue, dateFormat, previousDate) {
    if (previousDate) {
        setDateValue(safeDateFormat(previousDate, dateFormat));
    }
    else {
        setDateValue("");
    }
};
exports.handleInvalidDate = handleInvalidDate;
var setNewStartDate = function (newStartDate, newSelectedDates, setSelectedDates, setDateInView) {
    // if there is a start and end date already selected and the new start date is greater than the set end date
    // replace them
    if (newSelectedDates.length === 2
        && newStartDate.getTime() > newSelectedDates[1].getTime()) {
        setSelectedDates([newSelectedDates[1], newStartDate]);
        if (setDateInView) {
            setDateInView(newStartDate);
        }
        return;
    }
    newSelectedDates.splice(0, 1, newStartDate);
    setSelectedDates(newSelectedDates);
    if (setDateInView) {
        setDateInView(newSelectedDates[0]);
    }
};
exports.setNewStartDate = setNewStartDate;
var handleEndDateWithNoStartDate = function (newEndDate, setSelectedDates, setDateInView) {
    setSelectedDates([newEndDate]);
    if (setDateInView) {
        setDateInView(newEndDate);
    }
};
var setNewEndDate = function (newEndDate, newSelectedDates, setSelectedDates, setDateInView) {
    if (!newSelectedDates[0]) {
        return handleEndDateWithNoStartDate(newEndDate, setSelectedDates, setDateInView);
    }
    // if the selected length is already equal to two and the new end date time is less than
    // the set start date, replace them
    if (newSelectedDates.length === 2
        && newEndDate.getTime() < newSelectedDates[0].getTime()) {
        setSelectedDates([newEndDate, newSelectedDates[0]]);
        if (setDateInView) {
            setDateInView(newSelectedDates[0]);
        }
        return;
    }
    // if there is no endDate selected and newEndDate is less than the startDate
    // set the newEndDate to the startDate and the old startDate to the endDate
    if (!newSelectedDates[1]
        && newEndDate.getTime() < newSelectedDates[0].getTime()) {
        setSelectedDates([newEndDate, newSelectedDates[0]]);
        if (setDateInView) {
            setDateInView(newSelectedDates[0]);
        }
        return;
    }
    // if there is no end date already set, push the new end date;
    // otherwise replace the set end date with the new one
    if (!newSelectedDates[1]) {
        newSelectedDates.push(newEndDate);
        setSelectedDates(newSelectedDates);
        if (setDateInView) {
            setDateInView(newSelectedDates[1]);
        }
    }
    else {
        newSelectedDates.splice(1, 1, newEndDate);
        setSelectedDates(newSelectedDates);
        if (setDateInView) {
            setDateInView(newSelectedDates[1]);
        }
    }
};
exports.setNewEndDate = setNewEndDate;
//# sourceMappingURL=DatePicker.utils.js.map