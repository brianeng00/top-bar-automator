"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(require("react"));
var Popover = __importStar(require("@radix-ui/react-popover"));
var Divider_1 = require("../Divider");
var Input_1 = __importDefault(require("../Input/Input"));
var Typography_1 = require("../Typography");
var utils_1 = require("../utils");
var FilterItem_1 = __importDefault(require("./FilterItem"));
var FilterMenu_styles_1 = require("./FilterMenu.styles");
var FilterPage_1 = __importDefault(require("./FilterPage"));
/**
 * @description Custom type guard to check if filters is of GroupFilterProps type
 * @see https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards
 */
var isGroupFilter = function (filters) {
    if (!filters.length) {
        return false;
    }
    return filters[0].groupFilters !== undefined;
};
var filterGroupFilters = function (filter, val) { return (filter.groupFilters.filter(function (_a) {
    var filterName = _a.filterName;
    return filterName.toLowerCase().includes(val);
})); };
var FilterMenu = (0, react_1.forwardRef)(function (_a, ref) {
    var trigger = _a.trigger, side = _a.side, align = _a.align, sideOffset = _a.sideOffset, dataQA = _a.dataQA, ariaLabel = _a.ariaLabel, filters = _a.filters, customSearchFunc = _a.customSearchFunc, addButtonFunc = _a.addButtonFunc, $menuWidth = _a.$menuWidth, $menuHeight = _a.$menuHeight, radixPopoverProps = _a.radixPopoverProps, radixPopoverContentProps = _a.radixPopoverContentProps, $zIndex = _a.$zIndex, addButtonText = _a.addButtonText, _b = _a.onSelectFilterFunc, onSelectFilterFunc = _b === void 0 ? function () { } : _b, itemSelected = _a.itemSelected, topActions = _a.topActions, props = __rest(_a, ["trigger", "side", "align", "sideOffset", "dataQA", "ariaLabel", "filters", "customSearchFunc", "addButtonFunc", "$menuWidth", "$menuHeight", "radixPopoverProps", "radixPopoverContentProps", "$zIndex", "addButtonText", "onSelectFilterFunc", "itemSelected", "topActions"]);
    var _c = (0, react_1.useState)(), selectedFilter = _c[0], setSelectedFilter = _c[1];
    var _d = (0, react_1.useState)(""), searchValue = _d[0], setSearchValue = _d[1];
    // searchedFilters is the result of the provided filter prop, with text search applied to it.
    // It is re-computed every time the searchValue, filter prop of customSearchFunc changes.
    // Ultimately, it is the list of filters that will be displayed in the dropdown.
    var searchedFilters = (0, react_1.useMemo)(function () {
        if (customSearchFunc) {
            return customSearchFunc(searchValue, filters);
        }
        var val = searchValue.toLowerCase();
        if (isGroupFilter(filters)) {
            var newGroupFilters_1 = [];
            filters.forEach(function (filter) {
                var filteredGroupFilters = filterGroupFilters(filter, val);
                if (!filteredGroupFilters.length) {
                    return;
                }
                newGroupFilters_1.push({
                    label: filter.label,
                    groupFilters: filteredGroupFilters,
                });
            });
            return newGroupFilters_1;
        }
        else {
            return filters.filter(function (_a) {
                var filterName = _a.filterName;
                return filterName.toLowerCase().includes(val);
            });
        }
    }, [customSearchFunc, searchValue, filters]);
    var filtersLength = isGroupFilter(searchedFilters) ? (searchedFilters.flatMap(function (groupFilter) { return groupFilter.groupFilters; }).length) : searchedFilters.length;
    // Adding +1 here, as we want the input to focusable by keyboard. Therefore, the input will have an index of 0, and each list item will have an index of index+
    var filtersWithInput = filtersLength + 1;
    var _e = (0, react_1.useState)(0), focus = _e[0], setFocus = _e[1];
    var handleKeyDownFocus = function (e) {
        if (["ArrowDown", "ArrowUp"].includes(e.key)) {
            e.preventDefault();
            var mode = e.key === "ArrowDown" ? 1 : -1;
            setFocus((focus + mode + filtersWithInput) % filtersWithInput);
        }
    };
    var inputRef = (0, react_1.useRef)(null);
    var _f = (0, react_1.useState)(false), openMenu = _f[0], setOpenMenu = _f[1];
    var customOnOpenChange = function (prev) {
        if (isGroupFilter(filters) && !filters[0].groupFilters[0].filterComponent) {
            setOpenMenu(!prev);
        }
        else if (!isGroupFilter(filters) && filters.length && !filters[0].filterComponent) {
            setOpenMenu(!prev);
        }
        setOpenMenu(prev);
    };
    var handleOnFocus = function () {
        setFocus(0);
    };
    (0, react_1.useEffect)(function () {
        var _a, _b;
        if (inputRef) {
            if (focus === 0) {
                (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            }
            else {
                (_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.blur();
            }
        }
    }, [focus, inputRef]);
    var getGroupItemIndex = function (filterName) {
        if (!isGroupFilter(searchedFilters)) {
            return 0;
        }
        var flattendGroupFilters = searchedFilters.flatMap(function (groupFilter) { return groupFilter.groupFilters; });
        return flattendGroupFilters.findIndex(function (flattenGroupFilter) { return flattenGroupFilter.filterName === filterName; });
    };
    var renderFilterItem = function () {
        if (!searchedFilters.length) {
            return (react_1.default.createElement(FilterMenu_styles_1.NoResultMessage, { mt: topActions ? "0" : (0, utils_1.pxToRem)(40), dataQA: "no-result", variant: "displaySmall" }, "No results found."));
        }
        if (isGroupFilter(searchedFilters)) {
            return searchedFilters.map(function (searchGroupFilter, searchGroupFilterIndex) { return (react_1.default.createElement(react_1.default.Fragment, { key: "".concat(searchGroupFilter.label, "-").concat(searchGroupFilterIndex) },
                react_1.default.createElement(Typography_1.Typography, { variant: "bodyCopyBold", dataQA: "search-filter-label" }, searchGroupFilter.label),
                searchGroupFilter.groupFilters.map(function (groupFilter, index) { return (react_1.default.createElement(FilterItem_1.default, { dataQA: "".concat(dataQA, "-list-item-").concat(index), filter: groupFilter, key: "".concat(groupFilter.filterName).concat(groupFilter.filterId ? groupFilter.filterId : ""), setFocus: setFocus, setSelectedFilter: setSelectedFilter, 
                    // required to prevent input from losing focus while typing
                    focus: (focus !== 0) && (focus === getGroupItemIndex(groupFilter.filterName) + 1), index: getGroupItemIndex(groupFilter.filterName) + 1, onSelectFilterFunc: onSelectFilterFunc, closeMenu: function () { return setOpenMenu(false); }, "$isSelected": itemSelected === groupFilter.filterId || itemSelected === groupFilter.filterName })); }))); });
        }
        return searchedFilters.map(function (searchFilter, searchFilterIndex) { return (react_1.default.createElement(FilterItem_1.default, { dataQA: "".concat(dataQA, "-list-item-").concat(searchFilterIndex), filter: searchFilter, key: "".concat(searchFilter.filterName).concat(searchFilter.filterId ? searchFilter.filterId : ""), setFocus: setFocus, setSelectedFilter: setSelectedFilter, 
            // required to prevent input from losing focus while typing
            focus: (focus !== 0) && (focus === searchFilterIndex + 1), index: searchFilterIndex + 1, onSelectFilterFunc: onSelectFilterFunc, closeMenu: function () { return setOpenMenu(false); }, "$isSelected": itemSelected === searchFilter.filterId || itemSelected === searchFilter.filterName })); });
    };
    return (react_1.default.createElement(FilterMenu_styles_1.StyledPopoverRoot, __assign({ open: openMenu, onOpenChange: function (prev) {
            customOnOpenChange(prev);
        } }, radixPopoverProps, props),
        react_1.default.createElement(Popover.Trigger, { asChild: true }, trigger),
        react_1.default.createElement(FilterMenu_styles_1.StyledPopoverPortal, { "$menuHeight": $menuHeight, "$menuWidth": $menuWidth },
            react_1.default.createElement(FilterMenu_styles_1.StyledPopoverContent, __assign({ onKeyDown: handleKeyDownFocus, ref: ref, "$menuHeight": $menuHeight, "$menuWidth": $menuWidth, "$zIndex": $zIndex, align: align, side: side, sideOffset: sideOffset, role: "combobox" }, radixPopoverContentProps), selectedFilter ? (react_1.default.createElement(FilterPage_1.default, { filterId: selectedFilter.filterId, filterName: selectedFilter.filterName, closeButtonFunc: function () { return setSelectedFilter(undefined); }, filterComponent: selectedFilter.filterComponent, addButtonFunc: addButtonFunc, dataQA: dataQA, ariaLabel: ariaLabel, "$menuWidth": $menuWidth, "$menuHeight": $menuHeight, addButtonText: addButtonText })) : (react_1.default.createElement(react_1.default.Fragment, null,
                react_1.default.createElement(FilterMenu_styles_1.InputWrapper, null,
                    react_1.default.createElement(Input_1.default, { id: "filter-search", dataQA: "filter-search", onChange: function (_a) {
                            var event = _a.event;
                            return event && setSearchValue(event.target.value);
                        }, placeholder: "Search", leftIcon: "Search", key: "search", onFocus: handleOnFocus, value: searchValue, ref: inputRef, "aria-label": "type text or select a filter" }),
                    topActions && (react_1.default.createElement(react_1.default.Fragment, null,
                        react_1.default.createElement(FilterMenu_styles_1.TopActionsWrapper, null, topActions),
                        react_1.default.createElement(Divider_1.Divider, { dataQA: "top-actions-divider" })))),
                react_1.default.createElement(FilterMenu_styles_1.FilterList, { "$menuHeight": $menuHeight, "data-qa": "".concat(dataQA, "-filter-list") }, renderFilterItem())))))));
});
FilterMenu.displayName = "FilterMenu";
exports.default = FilterMenu;
//# sourceMappingURL=FilterMenu.js.map